\ requires ?TRUE ( n -- f ) IF VALUE IS NONZERO RETURN -1 ELSE 0
: ?TRUE IF -1 ELSE 0 THEN ;


POFF    \ TURN PROMPT OFF
EHON    \ STOP ON 1RST ERROR


\ The spi3 register addresses.
040003C00h CONSTANT	SPI3-CR1
040003C04h CONSTANT	SPI3-CR2
040003C08h CONSTANT	SPI3-SR
040003C0Ch CONSTANT	SPI3-DR
040003C10h CONSTANT	SPI3-CRCPR
040003C14h CONSTANT	SPI3-RXCRCR
040003C18h CONSTANT	SPI3-TXCRCR

: ?SPI3-DIRECTION
SPI3-CR1 @ 0C37Dh = IF ." IN UNIDIRECTIONAL MODE " THEN
SPI3-CR1 @ 037Dh = IF ." IN BIDIRECTIONAL  MODE " THEN
;

: .SPI3 ( -- )
CR  ?SPI3-DIRECTION CR
." SPI3-CR1 ADDR IS: " SPI3-CR1 .H ." , VALUE IS: " SPI3-CR1 @ .H	CR
." SPI3-CR2 ADDR IS: " SPI3-CR2 .H ." , VALUE IS: " SPI3-CR2 @ .H	CR
." SPI3-SR ADDR IS: " SPI3-SR .H ." , VALUE IS: " SPI3-SR @ .B 
." <<< 10b IS TXE AND 11b IS LOOPBACK" CR
." SPI3-DR ADDR IS: " SPI3-DR .H ." , VALUE IS: " SPI3-DR	@ .H CR
;

.SPI3

(
\ The GPIOA registers involved.
040020000h	CONSTANT	GPIOA-MODER
040020004h	CONSTANT	GPIOA-OTYPER
040020008h	CONSTANT	GPIOA-OSPEEDR
04002000Ch	CONSTANT	GPIOx-PUPDR
040020010h	CONSTANT	GPIOA_IDR
040020014h	CONSTANT	GPIOA_ODR
\ 040020018h	CONSTANT	GPIOA_BSRR	
\ 04002001Ch	CONSTANT	GPIOA_LCKR	
040020020h	CONSTANT	GPIOA_AFRL	
040020024h	CONSTANT	GPIOA_AFRH	
)

\ I NEED MACROS FOR A BUNCH OF THIS:
\ $ creation
\ WC creation
\ talking Create Does~!

(
\ The GPIOB registers involved.
040020414h	CONSTANT	GPIOB-ODR
040020441h	CONSTANT	GPIOB-IDR
040020400h	CONSTANT	GPIOB-MODER
)
(
\ The GPIOC registers involved.
040020814h	CONSTANT	GPIOC-ODR
040020810h	CONSTANT	GPIOC-IDR
040020800h	CONSTANT	GPIOC-MODER     \ NEEDED FOR BIT BANG TEST
)
\ 1 0 LSL .B 1b
\ 1 1 LSL .B 10b
\ 1 2 LSL .B 100b
\ 2 2 LSL .B 1000b
\ 3 2 LSL .B 1100b
\ 1 9 LSL .SB TOS> 1000000000b


\ ~WORD IS A WAIT UNTIL LOOP IS TRUE.
\ ?WORD AND .WORD ARE PRINTOUTS.
\ WORD? IS FLAG ARGUMENT GENERATOR, ON OR OFF.

(
TXE: Transmit buffer empty = BIT 1
0: Tx buffer not empty
1: Tx buffer empty
)
: ~TXE ( -- ) \ Until spi3 TXE ok.
 BEGIN SPI3-SR @ 2 AND UNTIL ;

: TXE? ( -- ON/OFF ) \ push on or off = TXE
 SPI3-SR @ 2 AND IF ON ELSE OFF THEN ;

(
RXNE: Receive buffer not empty = BIT 0
0: Rx buffer empty
1: Rx buffer not empty
)
: ~RXNE	( -- )
 BEGIN SPI3-SR @ 1 AND UNTIL ;

: RXNE?	( -- ON/OFF )	\ push on or off = RXNE
 SPI3-SR @ 1 AND IF ON ELSE OFF THEN ;

: ?RXNE  ;

: ?TXE ;

: ?OVR
  CR ." OVERFLOW FLAG IS " SPI3-SR @ 080h AND ?TRUE IF ." ON" ELSE ." OFF" THEN CR ;


: ?BSY ;

: ?MODF ;

\ .BT-CS	PB14	IS LEDGREEN
\ .DAC-CS	PB13	IS LEDRED
\ .ADC-CS	PB12	IS LEDBLUE
\ PSTAT SPI3 CHIP SELECT WORDS.
: .ADC-CS ( -- )	\ PB12
	CR ." ADC-CS IS " GPIOB-ODR @ 1000h AND ?TRUE IF ." OFF" ELSE ." ON" THEN CR ;

: .BT-CS ( -- )		\ PB14
	CR ." BT-CS IS "	GPIOB-ODR @ 4000h AND ?TRUE IF ." OFF" ELSE ." ON" THEN CR ;

: .DAC-CS ( -- )	\ PB13
	CR ." DAC-CS IS " GPIOB-ODR @ 2000h AND ?TRUE IF ." OFF" ELSE ." ON" THEN CR ;

: .CS	( -- )
	CR	
  .ADC-CS
	.BT-CS
	.DAC-CS
;

.CS

\ THIS SECTION OS LEAVING THE STACK VALUES

: SEEBIT@ ( 1-based-bit# addr -- )
	SWAP \ MAKES STACK ARGS SAME AS SETBIT/CLRBIT
	1 SWAP LSL >R @ R AND R> AND IF ." ON" ELSE ." OFF" THEN ;

: READ-SPI3-CR1 CR SPI3-CR1 @  .B ;

: READ-SPI3-CR2 CR SPI3-CR2 @  .B ;

: READ-SPI3-DR CR SPI3-DR @  .B ;

: READ-SPI3-SR CR SPI3-SR @ .B ;

: .SPI-REGISTERS
  \ TEXT PREFIX
  READ-SPI3-CR1
  \ TEXT PREFIX
  READ-SPI3-CR2
  \ TEXT PREFIX
  READ-SPI3-DR
  \ TEXT PREFIX
  READ-SPI3-SR
;

.SPI-REGISTERS

\ EN BAD SECTION TO FIX

: .SW1 ." SW1 (PC6) IS " 9 GPIOC-ODR SEEBIT@	;

: .SW2 ." SW2 (PC7) IS " 8 GPIOC-ODR SEEBIT@	;

: .SW3 ." SW3 (PC8) IS " 7 GPIOC-ODR SEEBIT@	;

: .SW4 ." SW4 (PC9) IS " 6 GPIOC-ODR SEEBIT@	;

: .SW CR .SW1 CR .SW2 CR .SW3 CR .SW4 CR ;

.SW

ON SW1
ON SW2 
ON SW3 
ON SW4

.SW

\ DW NOT WORKING YET DAC3W IS. ?EXTRA TIME WITH ."?
\ TWO THINGS DONE - C! AND DACWORD
: DW ( n18BITS=2CR+16dataBITS -- )
  DACWORD DUP !
  CR ." DACWORD IS " .H
  ON CS-DAC \ DAC PB13 CS (LEDRED) low=ON
	~TXE	( MSB )	DACWORD 2 + C@ 2 AND SPI3-DR C!
  ~RXNE	SPI3-DR C@  DROP  ?OVR
  1 MS
	~TXE	( MIDDLEBYTE ) DACWORD 1+ C@ SPI3-DR C!
  ~RXNE	SPI3-DR C@  DROP  ?OVR
  1 MS
	~TXE	( LSB ) DACWORD C@  SPI3-DR C!
  ~RXNE	SPI3-DR C@  DROP  ?OVR
	OFF CS-DAC \ DAC PB13 CS (LEDRED) high=OFF
;

\ SPI3 DAC WRITE 
\ lEAVING STACK STUFF IF ARG IS FFFF~!!!!
: DAC3W	( n18BITS=2CR+16dataBITS -- )
  DACWORD !
	CR ." DAC WRITE " DACWORD @ .H CR
	ON CS-DAC \ DAC PB13 CS (LEDRED) low=ON
	.DAC-CS
  ?OVR
	DACWORD 2 + C@ DUP CR ." 1RST BYTE WRITTEN = " 2 AND .H
	~TXE	2h AND SPI3-DR C!
	~RXNE	SPI3-DR C@
  DROP \ CR ." 1RST BYTE READ BACK = " .H
  ?OVR
	DACWORD 1+ C@ DUP CR ." 2ND BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
	~RXNE	SPI3-DR C@
	DROP \ CR ." 2ND BYTE READ BACK = " .H
  ?OVR
	DACWORD C@ DUP CR ." 3RD BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
	~RXNE	SPI3-DR C@
	DROP \ CR ." 3RD BYTE READ BACK = " .H
  OFF CS-DAC
  .DAC-CS
  ?OVR
CR
.S
;

: D3	( -- )
\	GPIOB-ODR 3 13d LSL CLRBITS \ DAC (LEDRED) and BT (LEDGREEN) CS low=ON PB13 & PB14
\ DW WILL KILL THE BT CS
\ CHECK FOR OVERRUN
\	SPI3-SR @ 0F0h AND IF ." OVERRUN ERROR, GOING BYE " BYE THEN
\	DO THE DAC
	FF,FFh 0 DO	\ I 1rst byte is AND'd with 2h
\ DW STOPPED WORKING		I  DW
    I DAC3W   \ DOES TH DAC CHIP SELECT
    ?KEY IF LEAVE THEN
		1 MS  \ SEEMS SOME DELAY IS REQUIRED?
	LOOP

\ GPIOB-ODR 3 13d LSL SETBITS \ DAC and BT CS HIGH PB13 & PB14
;

: DDW	( -- )
\	GPIOB-ODR 3 13d LSL CLRBITS \ DAC (LEDRED) and BT (LEDGREEN) CS low=ON PB13 & PB14
\ DW WILL KILL THE BT CS
\ CHECK FOR OVERRUN
\	SPI3-SR @ 0F0h AND IF ." OVERRUN ERROR, GOING BYE " BYE THEN
\	DO THE DAC
	FF,FFh 0 DO	\ I 1rst byte is AND'd with 3Fh
\ DW STOPPED WORKING		I  DW
    I DW
    ?KEY IF LEAVE THEN
		100 MS  \ SEEMS SOME DELAY IS REQUIRED?
	LOOP

\ GPIOB-ODR 3 13d LSL SETBITS \ DAC and BT CS HIGH PB13 & PB14
;

\ 1RST TRY DOCS HARD TO FIND~! CUBE DOES THIS.
(
typedef enum gpio_af {
    GPIO_AF_SPI_1_2              = 5,
    GPIO_AF_USART_1_2_3          = 7,
} gpio_af;
)

(
\ --------------------------------PORTB-----------------------------------------
\ Intialize PORTB_MODER pins this way.
\ GPIO PORT B Reset value: 0x0000 0280 = JTAG, WHICH WE DISABLE FOR SPI AND USE SWD
\ MODER is a 2 bit init for each of the 16 ports in a bank.
\ Enable PB12-15, and PB0-1 as Outputs for SPI BT, ADC and DAC BT CS AND RST
\ PROGRAM SPI3 AF ON PB3, PB4 AND PB5, TAKING OVER THE JTAG PINS
\ PORTB - Do std GPIO and level set init. Then do alternate function config.
PB15  BT-RST            is active high.	0x1
PB14  BT-CSn            is active low. 	0x1
PB13  DAC-CSn           is active low. 	0x1
PB12  ADC-CSn           is active low. 	0x1
PB11  SDA2              I2C START NOT USED
PB10  SCL2		
PB9   NC
PB8   NC
PB7   SDA1
PB6   SCL1              I2C END NOT USED
PB5   SPI3-MOSI         is AF, SPI3_MOSI 0x2
PB4   SPI3-MISO         is AF, SPI3_MISO 0x2
PB3   JTDO/SPI3-SCLK    is AF, SPI3_SCLK 0x2
PB2   BOOT0             Do not program	 0x0
PB1   ADC-PDNn          is active low. 	 0x1
PB0   ADC-RSTn          is active LOW.	 0x1
)

(
\ --------------------------------PORTC-----------------------------------------
\ GPIO PORT C Reset value: 0x0000 0000
\ MODER is a 2 bit init for each of the 16 ports in a bank.
\ Enable PC5 as input, and PC0-2-15 as Outputs for the ADC GAIN SWITCHES.
\ USART3 inited on PORT C, in the first section, after system clocks setup.
\ PORTC - Do std GPIO and level set init. Then do alternate function config.
\ Intialize PORTC pins this way.
PC15
PC14
PC13
PC12
PC11    UART3_TX        is AF.
PC10    UART3_RX        is AF.
PC9     SWITCH4         is active high.
PC8     SWITCH3         is active high.
PC7     SWITCH2         is active high.
PC6     SWITCH1         is active high.
PC5     ADC_DATA_READY  is actve high.
PC4
PC3
PC2     GAIN_SWITCH2    is active low.
PC1     GAIN_SWITCH1    is active low.
PC0     GAIN_SWITCH0    is active low.
)

EHOFF

\ STACK SANITY CHECK
.S

: .SPI3-DUMP
?SPI3-DIRECTION
\ DAC SWITCHES
.SW
.SPI3
.CS
\ FF,0h DAC3W
;

.SPI3
.SPI3-DUMP

EHON

: ADC-RESET \ GPIOB BIT 0 IS ACTIVE LOW
  GPIOB-ODR 1 CLRBITS 1 MS  GPIOB-ODR 1 SETBITS ;

\ ADC-PDN IS ON - FIX IN SOCINIT
: ?ADC-RSTn	." ADC-RSTn IS ACTIVE OFF AND NOW IS "( BIT ) 0 GPIOB-ODR SEEBIT@ CR ;
: ?ADC-PDN	." ADC-PDN IS ACTIVE ON AND NOW IS "( BIT ) 1 GPIOB-ODR SEEBIT@ CR ;

?ADC-RSTn
?ADC-PDN

: ADC-RREG \ 
	?OVR  \ Report OVR flag status.
	ON CS-ADC \ DAC PB12 CS (LEDBLUE) low=ON
	.ADC-CS
	?ADC-RSTn
	?ADC-PDN
\ THESE TWO BYTES SHOULD LOOP BACK
	11h DUP CR ." 1RST BYTE WRITTEN = " .H  \ print out the byte to write
	~TXE	SPI3-DR C!  \ wait for TXE and write 
	~RXNE	SPI3-DR C@  \ wait for RXNE and read
	CR ." 1RST BYTE READ BACK SHOULD = WRITE = " .H  \ EXPECTED WHAT WAS WRITTEN
 	?OVR
	1 DUP CR ." 2ND BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
	~RXNE	SPI3-DR C@
	CR ." 2ND BYTE READ BACK SHOULD = WRITE = " .H  \ EXPECTED WHAT WAS WRITTEN
  	?OVR
\ THESE WRITE SHOULD SEND DATA BACK ON MISO
  	0 DUP CR ." 3RD BYTE IS READ DATA 0 BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
	~RXNE	SPI3-DR C@
	CR ." 3RD BYTE READ BACK SHOULD EQUAL REGISTER DATA = " .H  \ EXPECTED DATA BACK
  	?OVR
	0 DUP CR ." 4TH BYTE IS READ DATA 0 BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
	~RXNE	SPI3-DR C@
	CR ." 4TH BYTE READ BACK SHOULD EQUAL REGISTER DATA = " .H  \ EXPECTED DATA BACK
  	?OVR
	OFF CS-ADC
CR
.S
;

\ WDR RDR ARE ATOMIC WORDS FOR THE LOOPBACK ISSUE.
: WDR ( n=8bits -- ) \ write to spi3 odr 7 layer fifo
	~TXE SPI3-DR C! ?OVR ;

: RDR ( n=8bits -- ) \ read spi3 odr 7 layer fifo
\ IF RXNE
	~RXNE SPI3-DR C@ .H  ?OVR ;

EHOFF
PON

\ $30 SketchPad~!

\ LBT \ ADT

.S

ON SW1
ON SW2 
ON SW3 
ON SW4

.SW

?ADC-RSTn
?ADC-PDN


ADC-RREG

