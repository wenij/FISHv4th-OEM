( IF THIS ERRS WITH A FLASH_SAVE'S DICT EHON DOESN'T WORK. )
( WORDS AVAILABLE:
PSTAT SPI:
~TXE   ~RXNE   ?OVR   DACWORD
PSTAT GPIO:
DACWB   ?TRUE   CS-ADC   CS-BT   CS-DAC   SW1   SW2   SW3   SW4   GS2
GS1   GS0   CLRBITS   SETBITS   ANDBITS   CLRBIT   SETBIT   SEEBIT
GPIOB-MODER   GPIOB-IDR   GPIOB-ODR   GPIOC-MODER   GPIOC-IDR
GPIOC-ODR
)

\ requires ?TRUE ( n -- f ) IF VALUE IS NONZERO RETURN -1 ELSE 0

POFF    \ TURN PROMPT OFF
EHON    \ STOP ON 1RST ERROR

(
\ The spi3 register addresses.
040003C00h CONSTANT	SPI3-CR1
040003C04h CONSTANT	SPI3-CR2
040003C08h CONSTANT	SPI3-SR
040003C0Ch CONSTANT	SPI3-DR
040003C10h CONSTANT	SPI3-CRCPR
040003C14h CONSTANT	SPI3-RXCRCR
040003C18h CONSTANT	SPI3-TXCRCR
)

: ?SPI3-DIRECTION ( -- ) \ PRINTOUT WORD
SPI3-CR1 @ 0C37Dh = IF ." IN UNIDIRECTIONAL MODE " THEN
SPI3-CR1 @ 037Dh = IF ." IN BIDIRECTIONAL  MODE " THEN
;

: .SPI3 ( -- ) \ PRINTOUT WORD - SPI3 REGISTERS
CR  ?SPI3-DIRECTION CR
." SPI3-CR1 ADDR IS: " SPI3-CR1 .H ." , VALUE IS: " SPI3-CR1 @ .H	CR
." SPI3-CR2 ADDR IS: " SPI3-CR2 .H ." , VALUE IS: " SPI3-CR2 @ .H	CR
." SPI3-SR ADDR IS: " SPI3-SR .H ." , VALUE IS: " SPI3-SR @ .B 
." <<< 10b IS TXE AND 11b IS LOOPBACK" CR
." SPI3-DR ADDR IS: " SPI3-DR .H ." , VALUE IS: " SPI3-DR	@ .H CR
;

\ UNIT TEST
?SPI3-DIRECTION
.S
.SPI3
.S

(
\ The gpioa registers involved.
040020000h	CONSTANT	GPIOA-MODER
040020004h	CONSTANT	GPIOA-OTYPER
040020008h	CONSTANT	GPIOA-OSPEEDR
04002000Ch	CONSTANT	GPIOx-PUPDR
040020010h	CONSTANT	GPIOA_IDR
040020014h	CONSTANT	GPIOA_ODR
\ 040020018h	CONSTANT	GPIOA_BSRR	
\ 04002001Ch	CONSTANT	GPIOA_LCKR	
040020020h	CONSTANT	GPIOA_AFRL	
040020024h	CONSTANT	GPIOA_AFRH	
)

\ I NEED MACROS FOR A BUNCH OF THIS:
\ $ creation
\ WC creation
\ talking Create Does~!

(
\ --------------------------------PORTB-----------------------------------------
\ Intialize PORTB_MODER pins this way.
\ GPIO PORT B Reset value: 0x0000 0280 = JTAG, WHICH WE DISABLE FOR SPI AND USE SWD
\ MODER is a 2 bit init for each of the 16 ports in a bank.
\ Enable PB12-15, and PB0-1 as Outputs for SPI BT, ADC and DAC BT CS AND RST
\ PROGRAM SPI3 AF ON PB3, PB4 AND PB5, TAKING OVER THE JTAG PINS
\ PORTB - Do std GPIO and level set init. Then do alternate function config.
PB15  BT-RST            is active high.	0x1
PB14  BT-CSn            is active low. 	0x1
PB13  DAC-CSn           is active low. 	0x1
PB12  ADC-CSn           is active low. 	0x1
PB11  SDA2              I2C START NOT USED
PB10  SCL2		
PB9   NC
PB8   NC
PB7   SDA1
PB6   SCL1              I2C END NOT USED
PB5   SPI3-MOSI         is AF, SPI3_MOSI 0x2
PB4   SPI3-MISO         is AF, SPI3_MISO 0x2
PB3   JTDO/SPI3-SCLK    is AF, SPI3_SCLK 0x2
PB2   BOOT0             Do not program	 0x0
PB1   ADC-PDNn          is active low. 	 0x1
PB0   ADC-RSTn          is active LOW.	 0x1
)

(
\ The gpiob registers involved.
040020414h	CONSTANT	GPIOB-ODR
040020441h	CONSTANT	GPIOB-IDR
040020400h	CONSTANT	GPIOB-MODER
)

(
\ --------------------------------PORTC-----------------------------------------
\ GPIO PORT C Reset value: 0x0000 0000
\ MODER is a 2 bit init for each of the 16 ports in a bank.
\ Enable PC5 as input, and PC0-2-15 as Outputs for the ADC GAIN SWITCHES.
\ USART3 inited on PORT C, in the first section, after system clocks setup.
\ PORTC - Do std GPIO and level set init. Then do alternate function config.
\ Intialize PORTC pins this way.
PC15
PC14
PC13
PC12
PC11    UART3_TX        is AF.
PC10    UART3_RX        is AF.
PC9     SWITCH4         is active high.
PC8     SWITCH3         is active high.
PC7     SWITCH2         is active high.
PC6     SWITCH1         is active high.
PC5     ADC_DATA_READY  is actve high.
PC4
PC3
PC2     GAIN_SWITCH2    is active low.
PC1     GAIN_SWITCH1    is active low.
PC0     GAIN_SWITCH0    is active low.
)
(
\ The gpioc registers involved.
040020814h	CONSTANT	GPIOC-ODR
040020810h	CONSTANT	GPIOC-IDR
040020800h	CONSTANT	GPIOC-MODER     \ NEEDED FOR BIT BANG TEST
)

\ 1 0 LSL .B 1b
\ 1 1 LSL .B 10b
\ 1 2 LSL .B 100b
\ 2 2 LSL .B 1000b
\ 3 2 LSL .B 1100b
\ 1 9 LSL .SB TOS> 1000000000b

\ REMINDER OF NAMING CONVENTIONS:
\ ~WORD IS A WAIT UNTIL LOOP IS TRUE.
\ ?WORD AND .WORD ARE PRINTOUTS.
\ WORD? IS FLAG GENERATOR, ON OR OFF.

: TXE? ( -- ON|OFF )  \ SPI3 TXE STATUS ON STACK
 SPI3-SR @ 2 AND IF ON ELSE OFF THEN ;

: RXNE?	( -- ON|OFF )  \ SPI3 RXNE STATUS ON STACK
 SPI3-SR @ 1 AND IF ON ELSE OFF THEN ;

\ UNIT TEST
TXE? DROP
.S
RXNE? DROP
.S

\ : ?RXNE  ;

\ : ?TXE ;

\ : ?BSY ;

\ : ?MODF ;

\ .BT-CS	PB14	IS LEDGREEN
\ .DAC-CS	PB13	IS LEDRED
\ .ADC-CS	PB12	IS LEDBLUE
\ PSTAT SPI3 CHIP SELECT WORDS.
: .ADC-CS ( -- )	\ PRINTOUT WORD STATUS OF PB12
	CR ." ADC-CS IS " GPIOB-ODR @ 1000h AND ?TRUE IF ." OFF" ELSE ." ON" THEN CR ;

: .BT-CS  ( -- )		\ PRINTOUT WORD STATUS OF PB14
	CR ." BT-CS IS "	GPIOB-ODR @ 4000h AND ?TRUE IF ." OFF" ELSE ." ON" THEN CR ;

: .DAC-CS ( -- )	\ PRINTOUT WORD STATUS OF PB13
	CR ." DAC-CS IS " GPIOB-ODR @ 2000h AND ?TRUE IF ." OFF" ELSE ." ON" THEN CR ;

: .CS     ( -- )  \ PRINTOUT WORD STATUS OF THE SPI CHIP SELECTS
	CR	
  .ADC-CS
	.BT-CS
	.DAC-CS
;

\ UNIT TEST
.CS
.S

: .SEEBIT ( 1-based-bit# addr -- )	\ PRINTOUT WORD OF A BIT @ AN ADDRESS
	SWAP \ MAKES STACK ARGS SAME AS SETBIT/CLRBIT
	1 SWAP LSL >R @ R AND R> AND IF ." ON" ELSE ." OFF" THEN ;

\ UNIT TEST
1 SPI3-SR .SEEBIT \ IS TXE ON?
.S

: READ-SPI3-CR1 CR SPI3-CR1 @  .B ;

: READ-SPI3-CR2 CR SPI3-CR2 @  .B ;

: READ-SPI3-DR CR SPI3-DR @  .B ;

: READ-SPI3-SR CR SPI3-SR @ .B ;

: .SPI-REGISTERS ( -- )	\ PRINTOUT WORD SPI3 REGISTERS
  \ TEXT PREFIX
  READ-SPI3-CR1
  \ TEXT PREFIX
  READ-SPI3-CR2
  \ TEXT PREFIX
  READ-SPI3-DR
  \ TEXT PREFIX
  READ-SPI3-SR
;

\ UNIT TEST
.SPI-REGISTERS
.S

: .SW1 ." SW1 (PC6) IS " 6 GPIOC-ODR .SEEBIT	;

: .SW2 ." SW2 (PC7) IS " 7 GPIOC-ODR .SEEBIT	;

: .SW3 ." SW3 (PC8) IS " 8 GPIOC-ODR .SEEBIT	;

: .SW4 ." SW4 (PC9) IS " 9 GPIOC-ODR .SEEBIT	;

: .SW CR .SW1 CR .SW2 CR .SW3 CR .SW4 CR ;

\ UNIT TEST
.SW
.S

OFF SW1
OFF SW2 
OFF SW3 
OFF SW4

.SW

ON SW1
ON SW2 
ON SW3 
ON SW4

.SW

EHOFF

\ STACK SANITY CHECK
.S

: .SPI3-DUMP
?SPI3-DIRECTION \
.SW             \ DAC SWITCHES
.SPI3           \
.CS             \
;

\ UNIT TEST
.SPI3
.S
.SPI3-DUMP
.S

\ END OF LOW LEVEL LAYER

EHON

\ START MID LEVEL API WORDS FOR HIGH LEVEL

\ USING ABORT AND IT'S A NO ERR MSG ?ERR ~!!! WHY RUN DON'T WORK ?
: ?OVR ( -- )	\ PRINTOUT WORD OF STATUS OF SPI3 OVR FLAG
\  CR ." OVERFLOW FLAG IS " SPI3-SR @ 040h AND ?TRUE
  CR ." OVERFLOW FLAG IS " OVR? 040h AND ?TRUE
  IF ." ON" ( ABORT ) ELSE ." OFF" THEN CR ;

\ UNIT TEST
?OVR
.S

\ DAC RESET STRATEGY IS TO SELECT, DESELECT, THEN RESELECT THE DAC.
\ IS THERE A TIMING REQUIREMNT? DOES NOT APPEAR TO BE.
\ PROBLEM IS HOW DO YOU KNOW YOU NEED TO RESET THE DAC?
\ IS THE BT THE REASON DACW GETS LOST? TEST W/O BT THEN.

: DAC-RESET \ --  \ SYNCn INTERRUPT P.15 DAC DATASHEET
\ DOES A WRITE NEED TO BE STARTED?
  ON CS-DAC OFF CS-DAC ON CS-DAC ;
  
\ UNIT TEST
DAC-RESET
.S

\ SPI3-WDR SPI3-RDR 
\ 0101XXXX IS WREG SO 01010000b (050h) IS WREG zero...

: SPI3-RDR ( -- n=8bits ) \ read spi3 odr 7 layer fifo
\ IF RXNE
	( ?OVR ) ~RXNE SPI3-DR C@
  CR ." SPI2-RDR = " .H  ?OVR ;

\ USES SPI3-RDR, TO AVOID OVERFLOW.
: SPI3-WDR ( n=8bits -- ) \ write to spi3 odr 7 layer fifo
	( ?OVR ) ~TXE SPI3-DR C! ?OVR
  SPI3-RDR ;

\ UNIT TEST
0 SPI3-WDR
.S
0FFh SPI3-WDR
.S

\ DEFINE SPI3-W and SPI3-RW WITH CHIP SELECTS EXTERNAL TO THE WORDS

: SPI3-W	( #BYTES-TO-WRITE n18BITS=2CR+16dataBITS -- )
  DUP DACWORD !
	CR ." WRITE WORD = " .H CR
  DUP
  CR ." # OF BYTES TO WRITE = " .D
  ?OVR
\ REVERSE ARGS AS LSBYTE BEING SENT 1RST & IF I 1RST AND WITH 2~!
  0 SWAP
  NEGATE
  DO
  I  NEGATE CR ." WRITING BYTE " .D
\ STACK LEAVINGS HERE
	DACWORD I NEGATE 1 - + C@ DUP 
  CR ." BYTE WRITTEN = " .H
	~TXE	( 2h AND ) SPI3-DR C!
  ?OVR
	~RXNE	SPI3-DR C@ DROP
  ?OVR
  ?KEY IF LEAVE THEN
  LOOP
CR
.S
;

\ UNIT TEST 
( Run manually as ?KEY abort's during download
DAC-RESET
3 FFFFh SPI3-W
OFF CS-DAC
DAC-RESET
3 0 SPI3-W
OFF CS-DAC
)

: SPI3-RW	( #BYTES-TO-WRITE n18BITS=2CR+16dataBITS -- )
  DUP DACWORD !
	CR ." WRITE WORD = " .H CR
  DUP
  CR ." # OF BYTES TO WRITE = " .D
  ?OVR
\ REVERSE ARGS AS LSBYTE BEING SENT 1RST & IF I 1RST AND WITH 2~!
  0 SWAP
  NEGATE
  DO
  I  NEGATE CR ." WRITING BYTE " .D
\ STACK LEAVINGS HERE
	DACWORD I NEGATE 1 - + C@ DUP 
  CR ." BYTE WRITTEN = " .H
	~TXE	( 2h AND ) SPI3-DR C!
	~RXNE	SPI3-DR C@
  CR ." BYTE READ BACK = " .H
  ?OVR
  ?KEY IF LEAVE THEN
  LOOP
CR
.S
;

\ UNIT TEST 
( Run manually as ?KEY abort's during download
DAC-RESET
3 FFFFh SPI3-RW
OFF CS-DAC
DAC-RESET
3 0 SPI3-RW
OFF CS-DAC
)

: DACW ( n18BITS=2CR+16dataBITS -- )
\ ADDED RUNTIME VS DACW IS WHY THIS WORKS VS DACW~!?!
  DACWORD !
	CR ." DAC WRITE " DACWORD @ .H CR
\ HERE DACW DOES DAC RESET
	ON CS-DAC \ DAC PB13 CS (LEDRED) low=ON
\ IS THIS WHAT HELP?
	.DAC-CS
  ?OVR
\ HERE DACW DOESN'T SPEN RUNTIME W\PRINTOUT
	DACWORD 2 + C@ DUP CR ." 1RST BYTE WRITTEN = " 2 AND .H
	~TXE	2h AND SPI3-DR C!
\ HERE DACW READS DR AND DROPS IT. WE SPEND RUNTIME WITH ANOTHER PRINTOUT.
	~RXNE	SPI3-DR C@
  DROP \ CR ." 1RST BYTE READ BACK = " .H
  ?OVR
	DACWORD 1+ C@ DUP CR ." 2ND BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
	~RXNE	SPI3-DR C@
	DROP \ CR ." 2ND BYTE READ BACK = " .H
  ?OVR
	DACWORD C@ DUP CR ." 3RD BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
	~RXNE	SPI3-DR C@
	DROP \ CR ." 3RD BYTE READ BACK = " .H
  OFF CS-DAC
  .DAC-CS
  ?OVR
CR
.S
;

\ UNIT TEST EXPECT ALL SWITCHES ON-REFv = 4.08.
\ SET DAC TO GROUND.
FFFFh DACW
.S

: DAC-RAMP	( -- )  \ FF,FFh 0 DO loop
\	GPIOB-ODR 3 13d LSL CLRBITS \ DAC (LEDRED) and BT (LEDGREEN) CS low=ON PB13 & PB14
  ON CS-DAC
  FF,FFh 0 DO	\ I = msbyte = zero
    CR ." .......LOOP INDEX IS........ " I .H
\    I 1FFF / IF 1000 MS THEN 
    DAC-RESET
    \ DAC-RESET
    1 0 SPI3-W
    2 I SPI3-W
    ?KEY IF LEAVE THEN
		1 MS  \ SEEMS SOME DELAY IS REQUIRED?
	LOOP
  OFF CS-DAC
\ GPIOB-ODR 3 13d LSL SETBITS \ DAC and BT CS HIGH PB13 & PB14
;

\ UNIT TEST 
( Run manually as ?KEY abort's AND DELAY LOOPS ABORT during download
DAC-RAMP
.S
)


: LBT ( -- )  \ IS DAC3W ADT WITHOUT THE CHIP SELECTS
  ?OVR  \ Report OVR flag status.
\ THESE TWO BYTES SHOULD LOOP BACK
	10h DUP CR ." 1RST BYTE WRITTEN = " .H  \ print out the byte to write
	~TXE	SPI3-DR C!  \ wait for TXE and write 
  1 MS
	~RXNE	SPI3-DR C@  \ wait for RXNE and read
	CR ." 1RST BYTE READ BACK SHOULD = WRITE = " .H  \ EXPECTED WHAT WAS WRITTEN
  ?OVR
	1 DUP CR ." 2ND BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
  1 MS
  	~RXNE	SPI3-DR C@
	CR ." 2ND BYTE READ BACK SHOULD = WRITE = " .H  \ EXPECTED WHAT WAS WRITTEN
  ?OVR
\ THESE WRITE SHOULD SEE DATA BACK ON MISO
  0 DUP CR ." 3RD BYTE IS READ DATA 0 BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
  1 MS
	~RXNE	SPI3-DR C@
	CR ." 3RD BYTE READ BACK SHOULD EQUAL REGISTER DATA = " .H  \ EXPECTED DATA BACK
  ?OVR
	0 DUP CR ." 4TH BYTE IS READ DATA 0 BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
  1 MS
	~RXNE	SPI3-DR C@
	CR ." 3RD BYTE READ BACK SHOULD EQUAL REGISTER DATA = " .H  \ EXPECTED DATA BACK
  ?OVR
CR
.S
;

\ $30 SketchPad~!

\ LBT \ ADT

.S

ON SW1
ON SW2 
ON SW3 
ON SW4

.SW

EHON
\ FISH NOT SEEING DRDYn AND RESET AND PDN CONVERSION MAKES NO DIFFERENCE
\ CARSTENS CODE SEEMS TO WORK SO CONTRAST
: ADC-RESET \ GPIOB BIT 0 IS ACTIVE LOW
\ Reset chip
  GPIOB-ODR 1 CLRBITS 1 MS  GPIOB-ODR 1 SETBITS ;

: ADC-PDN \ GPIOB BIT 0 IS ACTIVE LOW
\ Initiate a conversion
  GPIOB-ODR 2 CLRBITS 1 MS  GPIOB-ODR 2 SETBITS ;


: ADT ( -- )  \ 
	ON CS-ADC \ ADC PB12 CS (LEDBLUE) low=ON
	.ADC-CS
  ?OVR
\ THESE TWO BYTES SHOULD LOOP BACK
	11h DUP CR ." 1RST BYTE WRITTEN = " .H
	~TXE	SPI3-DR C!
	~RXNE	SPI3-DR C@
	CR ." 1RST BYTE READ BACK SHOULD = WRITE = " .H  \ EXPECTED WHAT WAS WRITTEN
  ?OVR
	1 DUP CR ." 2ND BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
	~RXNE	SPI3-DR C@
 
	CR ." 2ND BYTE READ BACK SHOULD = WRITE = " .H  \ EXPECTED WHAT WAS WRITTEN
  ?OVR
\ THESE WRITE SHOULD SEE DATA BACK ON MISO
  0 DUP CR ." 3RD BYTE IS READ DATA 0 BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
	~RXNE	SPI3-DR C@
	CR ." 3RD BYTE READ BACK SHOULD EQUAL REGISTER DATA = " .H  \ EXPECTED DATA BACK
  ?OVR
	0 DUP CR ." 4TH BYTE IS READ DATA 0 BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
	~RXNE	SPI3-DR C@
	CR ." 3RD BYTE READ BACK SHOULD EQUAL REGISTER DATA = " .H  \ EXPECTED DATA BACK

  OFF CS-ADC
  .ADC-CS
  ?OVR
CR
.S
;

: ?ADC-RSTn	." ADC-RSTn IS ACTIVE OFF AND NOW IS "( BIT ) 0 GPIOB-ODR .SEEBIT CR ;
: ?ADC-PDNn	." ADC-PDN IS ACTIVE OFF AND NOW IS "( BIT ) 1 GPIOB-ODR .SEEBIT CR ;

?ADC-RSTn
?ADC-PDNn

: LBT+ARGS ( N N N N -- ) \ IS DAC3W ADT WITHOUT THE CHIP SELECTS
  ?OVR  \ Report OVR flag status.
\ THESE TWO BYTES SHOULD LOOP BACK
	DUP CR ." 1RST BYTE WRITTEN = " .H  \ print out the byte to write
	~TXE	SPI3-DR C!  \ wait for TXE and write 
  1 MS
	~RXNE	SPI3-DR C@  \ wait for RXNE and read
	CR ." 1RST BYTE READ BACK SHOULD = WRITE = " .H  \ EXPECTED WHAT WAS WRITTEN
  ?OVR
	 DUP CR ." 2ND BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
  1 MS
  	~RXNE	SPI3-DR C@
	CR ." 2ND BYTE READ BACK SHOULD = WRITE = " .H  \ EXPECTED WHAT WAS WRITTEN
  ?OVR
\ THESE WRITE SHOULD SEE DATA BACK ON MISO
   DUP CR ." 3RD BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
  1 MS
	~RXNE	SPI3-DR C@
	CR ." 3RD BYTE READ BACK SHOULD EQUAL REGISTER DATA = " .H  \ EXPECTED DATA BACK
  ?OVR
	 DUP CR ." 4TH BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
  1 MS
	~RXNE	SPI3-DR C@
	CR ." 3RD BYTE READ BACK SHOULD EQUAL REGISTER DATA = " .H  \ EXPECTED DATA BACK
  ?OVR
CR
.S
;

.SW

?ADC-RSTn


?ADC-PDNn

\ TESTING DAC-RAMP
( RUN MANUALLY - ?KEY ISSUE 
DAC-RAMP
)

\ TESTING DACW WITH BT UNPLUGGED
(
FFFFh DACW
0 DACW
)

( NOTES ON WHAT TO FIX:
DO I NEED TO ADD BSY CHECK?
OVR - VERIFY YOU HAVE TO READ BACK EVERY WRITE TO NOT OVR
RM00033 P. 724:
Clearing the OVR bit is done by a read operation on the SPI_DR register,
followed by a read access to the SPI_SR register.
?SEEMS THE DR READ CLEARS IT.
)


: ADC-RREG-0-AND-1 \ 
	?OVR  \ Report OVR flag status.
	ON CS-ADC \ DAC PB12 CS (LEDBLUE) low=ON
	.ADC-CS
	?ADC-RSTn
	?ADC-PDNn
\ THESE TWO BYTES SHOULD LOOP BACK
	10h DUP CR ." 1RST BYTE WRITTEN = " .H  \ print out the byte to write
	~TXE	SPI3-DR C!  \ wait for TXE and write 
  1 MS
	~RXNE	SPI3-DR C@  \ wait for RXNE and read
	CR ." 1RST BYTE READ BACK SHOULD = WRITE = " .H  \ EXPECTED WHAT WAS WRITTEN
 	?OVR
	1 DUP CR ." 2ND BYTE WRITTEN = "  .H   \ # REGISTERS TO READ -1
	~TXE	SPI3-DR C!
  1 MS
	~RXNE	SPI3-DR C@
	CR ." 2ND BYTE READ BACK SHOULD = WRITE = " .H  \ EXPECTED WHAT WAS WRITTEN
  	?OVR
\ THESE WRITE SHOULD SEND DATA BACK ON MISO
  0 DUP CR ." 3RD BYTE IS READ DATA 0 BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
  1 MS
	~RXNE	SPI3-DR C@
	CR ." 3RD BYTE READ BACK (after ADC reset) = 030h = " .H  \ EXPECTED DATA BACK
  	?OVR
	0 DUP CR ." 4TH BYTE IS READ DATA 0 BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
  1 MS
	~RXNE	SPI3-DR C@
	CR ." 4TH BYTE READ BACK (after ADC reset) = 01 = " .H  \ EXPECTED DATA BACK
  	?OVR
	OFF CS-ADC
CR
.S
;

\ 
: ADC-RREG-ALL  ( -- )  \ THE 1 MS DELAYS COVER THE t6 WAIT = DESCRIBED IN RREG
	?OVR  \ Report OVR flag status.
	ON CS-ADC \ DAC PB12 CS (LEDBLUE) low=ON
	.ADC-CS
	?ADC-RSTn
	?ADC-PDNn
\ THESE TWO BYTES SHOULD LOOP BACK BUT DON'T
	10h DUP CR ." 1RST BYTE WRITTEN = " .H  \ print out the byte to write
	~TXE	SPI3-DR C!  \ wait for TXE and write 
  1 MS
	~RXNE	SPI3-DR C@  \ wait for RXNE and read
	CR ." 1RST BYTE READ BACK SHOULD = WRITE = " .H  \ EXPECTED WHAT WAS WRITTEN
 	?OVR
	10d DUP CR ." 2ND BYTE WRITTEN = "  .H
	~TXE	SPI3-DR C!
  1 MS
	~RXNE	SPI3-DR C@
	CR ." 2ND BYTE READ BACK SHOULD = WRITE = " .H  \ EXPECTED WHAT WAS WRITTEN
  	?OVR
    .S
\ THESE WRITE SHOULD SEND DATA BACK ON MISO
  11d 0 DO
  	0 DUP CR ." WRITE DATA 0 FOR DATA = "  .H
	~TXE	SPI3-DR C!
  1 MS
	~RXNE	SPI3-DR C@
	CR I .D ." REGITER BYTE READ BACK " .H  \ EXPECTED DATA BACK
  	?OVR
  LOOP
	OFF CS-ADC
CR
.S
;

: ADC-RREG  \ #OF-REGISTERS-TO-READ STARTING-REGISTER# --  \ DATA BYTES BACK
  ON CS-ADC
  10h AND \ ADD STARTING-REGISTER TO COMMAND BYTE
  1 SWAP SPI3-W
  0 DO
  	0 DUP CR ." WRITE DATA 0 FOR DATA = "  .H
    ~TXE	SPI3-DR C!
    1 MS
    ~RXNE	SPI3-DR C@
    CR I .D ." REGITER BYTE READ BACK " .H  \ EXPECTED DATA BACK
  	?OVR
  LOOP
  OFF CS-ADC
;

(
3 10000000h SPI3-RW
ADC-RREG-ALL
)


: ADC-INIT  \ --  \ 

\ Reset the ADC by pulsing the Reset Line.
\ MINIMUM 4us BEETWEEN PULSE - INTERPRETER SHOULD PROVIDE THAT.
\ pb0
  0 GPIOB-ODR CLRBIT
  1 MS
  0 GPIOB-ODR SETBIT
  
  ADC-RREG-0-AND-1
  
\ Enable input buffer
\ Send ADCON control register expecting no response.

\ 0101XXXX IS WREG SO 01010000b (050h) IS THE 1rst COMMAND byte template
\ 0 is the STATUS register.
\ 2 is the bit (BUFEN) in the register to set .

\ 050h IS WRITE REGISTER STARING WITH ZERO'TH REGISTER COMMAND
  3 500002h SPI3-W  \ #BYTES-TO-WRITE n18BITS=2CR+16dataBITS -- 
  ADC-RREG-0-AND-1  \ REG 0 SHOULD BE 32h - NOT YET~!

( NOT WORKING CARTSEB SUGGESTED a delay between the first two bytes.
THIS DIDN'T HELP AND I SEE NOTHING IN THE DOC
1 050h SPI3-W
1 MS
1 0 SPI3-W
1 MS
1 02 SPI3-W
)
ADC-RREG-0-AND-1  \ REG 0 SHOULD BE 32h - NOT YET~!

\ Set PGA to 2 = +-2.5v
\ 3 500002h SPI3-W  \ #BYTES-TO-WRITE n18BITS=2CR+16dataBITS -- 
;

\ GPIOC PIN 5 IS ADC DRDYn AND NEED TO BE AN INPUT!
\ FIX IN SOC_INIT.

\ ?ADC-DRDY \ -- ON|OFF \ Query THE PIN, NOT THE STATUS REGISTER
: ?ADC-DRDY 
  GPIOC-ODR @ 20h AND IF ON ELSE OFF THEN
;

\ UNIT TEST 
?ADC-DRDY
.S


: ~ADC-DRDY
;

\ ADC-READ  \ -- \ Initially create all sorts of readouts @ what the setup is.

: ADC-READ
;

\ FISH NOT SEEING DRDYn AND RESET AND PDN CONVERSION MAKES NO DIFFERENCE
\ CARSTENS CODE SEEMS TO WORK SO CONTRAST

EHOFF

