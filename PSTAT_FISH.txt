\ NOTE2ME: DUP DOESNT ERROR WHEN STACK IS EMPTY. IT PUSHES A ZERO~!

POFF    \ TURN LINE RESPONCE OFF
EHON    \ STOP ON 1RST ERROR

\ PSTAT_

\ The spi1 register addresses.
040013000h CONSTANT	SPI1-CR1
040013004h CONSTANT	SPI1-CR2
040013008h CONSTANT	SPI1-SR
04001300Ch CONSTANT	SPI1-DR
040013010h CONSTANT	SPI1-CRCPR
040013014h CONSTANT	SPI1-RXCRCR
040013018h CONSTANT	SPI1-TXCRCR

: .SPI1 ( -- )
CR
." SPI1-CR1 ADDR IS: " SPI1-CR1 .H ." , VALUE IS: " SPI1-CR1 @ .B	CR
." SPI1-CR2 ADDR IS: " SPI1-CR2 .H ." , VALUE IS: " SPI1-CR2 @ .B	CR
." SPI1-SR ADDR IS: " SPI1-SR .H ." , VALUE IS: " SPI1-SR @ .B 
." <<< 10b IS TXE AND 11b IS LOOPBACK" CR
." SPI1-DR ADDR IS: " SPI1-DR .H ." , VALUE IS: " SPI1-DR	@ .B CR
;

.SPI1

\ The gpio registers involved.
040020000h	CONSTANT	GPIOA-MODER
040020004h	CONSTANT	GPIOA-OTYPER
040020008h	CONSTANT	GPIOA-OSPEEDR
04002000Ch	CONSTANT	GPIOx-PUPDR
040020010h	CONSTANT	GPIOA_IDR
040020014h	CONSTANT	GPIOA_ODR
\ 040020018h	CONSTANT	GPIOA_BSRR	
\ 04002001Ch	CONSTANT	GPIOA_LCKR	
040020020h	CONSTANT	GPIOA_AFRL	
040020024h	CONSTANT	GPIOA_AFRH	

: WDR ( n=8bits -- ) \ write to spi1 odr 7 layer fifo
	SPI1-DR C! ;

: RDR ( n=8bits -- ) \ read spi1 odr 7 layer fifo
	SPI1-DR C@ ;

\ I NEED MACROS FOR A BUNCH OF THIS:
\ $ creation
\ WC creation
\ talking Create Does~!

: .SPI1-DIRECTION?
CR ." THIS IS FROM ALT TESTING OF WHY SPI1 HAS ISSUES" CR
SPI1-CR1 @ 0C37Dh = IF ." IN UNIDIRECTIONAL MODE " THEN
SPI1-CR1 @ 037Dh = IF ." IN BIDIRECTIONAL  MODE " THEN
;


\ The gpio registers involved.
040020414h	CONSTANT	GPIOB-ODR
040020441h	CONSTANT	GPIOA-IDR
040020400h	CONSTANT	GPIOA-MODER

\ The gpio registers involved.
040020814h	CONSTANT	GPIOC-ODR
040020810h	CONSTANT	GPIOC-IDR
040020800h	CONSTANT	GPIOC-MODER     \ NEEDED FOR BIT BANG TEST

\ 1 0 LSL .B 1b
\ 1 1 LSL .B 10b
\ 1 2 LSL .B 100b
\ 2 2 LSL .B 1000b
\ 3 2 LSL .B 1100b
\ 1 9 LSL .SB TOS> 1000000000b

: SETBIT ( 0-based-bit# addr -- )
	>R              \ STORE @ADDR VALUE
	1h SWAP LSL
	R  @ XOR        \ WHAT IS IT? IT'S NOT AND!
	R>
\	CR .SH
	!
;

: CLRBIT ( 0-based-bit# addr -- )
	>R              \ STORE @ADDR VALUE
	1h SWAP LSL
	R  @ XOR        \ WHAT IS IT? IT'S NOT AND!
	R>
\	CR .SH
	!
;

VAR TS 0 TS !
TS ?
1 TS SETBIT TS ?

\ PSTAT SWITCH WORDS, ON THE DAC
: SW1 ( ON | OFF -- )	\ BIT 9
	IF 9 GPIOC-ODR SETBIT ELSE 9 GPIOC-ODR CLRBIT THEN ;

: SW2 ( ON | OFF -- )	\ BIT 8
	IF 8 GPIOC-ODR SETBIT ELSE 8 GPIOC-ODR CLRBIT THEN ;

: SW3 ( ON | OFF -- )	\ BIT 7
	IF 7 GPIOC-ODR SETBIT ELSE 7 GPIOC-ODR CLRBIT THEN ;

: SW4 ( ON | OFF -- )	\ BIT 6
	IF 6 GPIOC-ODR SETBIT ELSE 6 GPIOC-ODR CLRBIT THEN ;

\ SPI1 WORDS FOR THE DAC.
\ ~WORD IS A WAIT UNTIL LOOP IS TRUE.
\ ?WORD IS A DISPLAY WORD.
\ WORD? IS FLAG GENERATOR, ON OR OFF.

(
TXE: Transmit buffer empty
0: Tx buffer not empty
1: Tx buffer empty
)
: ~TXE ( -- ) \ Until spi1 TXE ok.
 BEGIN SPI1-SR @ 2 AND UNTIL ;

: TXE? ( -- ON/OFF ) \ push on or off = TXE
 SPI1-SR @ 2 AND IF ON ELSE OFF THEN ;

(
RXNE: Receive buffer not empty
0: Rx buffer empty
1: Rx buffer not empty
)
: ~RXNE	( -- )
 BEGIN SPI1-SR @ 1 AND UNTIL ;

: RXNE?	( -- ON/OFF )	\ push on or off = RXNE
 SPI1-SR @ 1 AND IF ON ELSE OFF THEN ;

: ?RXNE  ;

: ?TXE ;

: ?OVR ;

: ?BSY ;

: ?MODF ;

\ .BT-CS	PB14	IS LEDGREEN
\ .DAC-CS	PB13	IS LEDRED
\ .ADC-CS	PB12	IS LEDBLUE
\ PSTAT SPI1 CHIP SELECT WORDS.
: .ADC-CS ( -- )	\ PB12
	GPIOC-ODR @ 1000h AND CR ." ADC-CS IS "	IF ." ON" ELSE ." OFF" THEN ;

: .BT-CS ( -- )		\ PB14
	GPIOC-ODR @ 4000h AND CR ." BT-CS IS "	IF ." ON" ELSE ." OFF" THEN ;

: .DAC-CS ( -- )	\ PB13
	GPIOC-ODR @ 2000h AND CR ." DAC-CS IS " IF ." ON" ELSE ." OFF" THEN ;

: .CS	( -- )
	CR	.ADC-CS
	CR	.BT-CS
	CR	.DAC-CS
;

.CS

\ TWO THINGS DONE - C! AND ...
: DW ( N3 n2 n1=MSB -- )
\ this may have to read back false values, because the spi engine always reads back something.
 	13d GPIOB-ODR CLRBIT \ DAC PB13 CS (LEDRED) low=ON
	~TXE	( n1 )	3Fh AND SPI1-DR C!
	~TXE	( n2 )  SPI1-DR C!
	~TXE	( n3 ) 	SPI1-DR C!
	GPIOB-ODR 1 13d LSL SETBITS \ DAC PB13 CS (LEDRED) high=OFF
;

: TS	( -- )
	GPIOB-ODR 3 13d LSL CLRBITS \ DAC (LEDRED) and BT (LEDGREEN) CS low=ON PB13 & PB14

\ CHECK FOR OVERRUN
	SPI1-SR @ 0F0h AND IF ." OVERRUN ERROR, GOING BYE " BYE THEN
\ now do the 3 write ramp.

\	DO A 3 BYTE Write FOR THE DAC
	FFh 0 DO	\ use I for the last 2 bytes and 1rst bYte will always be 3Fh
		I I I DW
		100 MS
	LOOP	\ write spi dr
	1 MS
	GPIOB-ODR 3 13d LSL SETBITS \ DAC and BT CS HIGH PB13 & PB14
;

: DAC-SCOPE-TEST BEGIN TS ?KEY UNTIL ;

\ SPI1 loopback test WORDS here:
: DAC-LB	( N1 N2 N3 -- )\
	CR ." DAC-CS LOOPBACK TEST"
	13d GPIOB-ODR CLRBIT            \ DAC PB13 CS (LEDRED) low=ON
	.DAC-CS
	DUP CR ." 1RST BYTE WRITTEN = " .H
	~TXE	3Fh AND SPI1-DR C!
	~RXNE	SPI1-DR C@
	CR ." 1RST BYTE READ BACK = " .H

	DUP CR ." 2ND BYTE WRITTEN = " .H
	~TXE	SPI1-DR C!
	~RXNE	SPI1-DR C@
	CR ." 2ND BYTE READ BACK = " .H

	DUP CR ." 3RD BYTE WRITTEN = " .H
	~TXE	SPI1-DR C!
	~RXNE	SPI1-DR C@
	CR ." 3RD BYTE READ BACK = " .H
\	GPIOB-ODR 1 13d LSL SETBITS     \ DAC PB13 CS (LEDRED) high=OFF
	12d GPIOB-ODR SETBIT            \ DAC PB13 CS (LEDRED) high=OFF
	.DAC-CS
CR ." CHECKed, no OVERRUN~! " CR
;

(
DAC-LB SHOW FF READ BACK NO MATTER WAHT VALUE, SELECTING THE DAC
THIS NEXT WORD WILL NOT SELECT ANY SPI1 PRERIPHERAL AND SEE...
)

: SPI1-ONLY-LB	( N1 N2 N3 -- )
	." NO CHIP SELECTED LOOPBACK TEST" CR 
	.CS
	DUP 3Fh AND CR ." 1RST BYTE WRITTEN = " .H
	~TXE	3Fh AND SPI1-DR C!
	~RXNE	SPI1-DR C@
	CR ." 1RST BYTE READ BACK = " .H
	.CS
	DUP CR ." 2ND BYTE WRITTEN = " .H
	~TXE	SPI1-DR C!
	~RXNE	SPI1-DR C@
	CR ." 2ND BYTE READ BACK = " .H
	.CS
	DUP CR ." 3RD BYTE WRITTEN = " .H
	~TXE	SPI1-DR C!
	~RXNE	SPI1-DR C@
	CR ." 3RD BYTE READ BACK = " .H
CR ." CHECKed, no OVERRUN~! " CR
;

: ADC-LB	( N1 N2 N3 -- )\
	." ADC-CS LOOPBACK TEST"
	12d GPIOB-ODR CLRBIT            \ ADC PB12 CS (LEDBLUE) low=ON
	.ADC-CS
	DUP 3Fh AND CR ." 1RST BYTE WRITTEN = " .H
	~TXE	3Fh AND SPI1-DR C!
	~RXNE	SPI1-DR C@
	CR ." 1RST BYTE READ BACK = " .H

	DUP CR ." 2ND BYTE WRITTEN = " .H
	~TXE	SPI1-DR C!
	~RXNE	SPI1-DR C@
	CR ." 2ND BYTE READ BACK = " .H

	DUP CR ." 3RD BYTE WRITTEN = " .H
	~TXE	SPI1-DR C!
	~RXNE	SPI1-DR C@
	CR ." 3RD BYTE READ BACK = " .H
\	GPIOB-ODR 1 12d LSL SETBITS     \ ADC PB12 CS (LEDBLUE) high=OFF
	12d GPIOB-ODR SETBIT            \ ADC PB12 CS (LEDBLUE) high=OFF
	.ADC-CS
CR ." CHECKed, no OVERRUN~! " CR
;

: SEEBIT@ ( 1-based-bit# addr -- )
	SWAP \ MAKES STACK ARGS SAME AS SETBIT/CLRBIT
	1 SWAP LSL >R @ R AND R> AND IF ." ON" ELSE ." OFF" THEN ;

: READ-SPI1-CR1 SPI1-CR1 @ DUP .B ;

: READ-SPI1-CR2 SPI1-CR2 @ DUP .B ;

: READ-SPI1-DR SPI1-DR @ DUP .B ;

: READ-SPI1-SR SPI1-SR @ DUP .B ;

: .SPI-REGISTERS
  \ TEXT PREFIX
  READ-SPI1-CR1
  \ TEXT PREFIX
  READ-SPI1-CR2
  \ TEXT PREFIX
  READ-SPI1-DR
  \ TEXT PREFIX
  READ-SPI1-SR
;

.SPI-REGISTERS

: .SW1 ." SW1 (PC6) IS " 9 GPIOC-ODR SEEBIT@	;

: .SW2 ." SW2 (PC7) IS " 8 GPIOC-ODR SEEBIT@	;

: .SW3 ." SW3 (PC8) IS " 7 GPIOC-ODR SEEBIT@	;

: .SW4 ." SW4 (PC9) IS " 6 GPIOC-ODR SEEBIT@	;

: .SW CR .SW1 CR .SW2 CR .SW3 CR .SW4 CR ;

.SW

\ BUT lsb ORDER IS disordered is WHAT SCOPE SEEs~!
\ Yet register LSBFIRST bit is zero~!
\ CHECK RXE AND OVERRUN~!
\ 1RST TRY DOCS HARD TO FIND~! CUBE DOES THIS.
(
typedef enum gpio_af {
    GPIO_AF_SPI_1_2              = 5,
    GPIO_AF_USART_1_2_3          = 7,
} gpio_af;
)

(
\ --------------------------------PORTB-----------------------------------------
\ Intialize PORTB_MODER pins this way.
\ GPIO PORT B Reset value: 0x0000 0280 = JTAG, WHICH WE DISABLE FOR SPI AND USE SWD
\ MODER is a 2 bit init for each of the 16 ports in a bank.
\ Enable PB12-15, and PB0-1 as Outputs for SPI BT, ADC and DAC BT CS AND RST
\ PROGRAM SPI1 AF ON PB3, PB4 AND PB5, TAKING OVER THE JTAG PINS
\ PORTB - Do std GPIO and level set init. Then do alternate function config.
PB15  BT-RST            is active high.	0x1
PB14  BT-CSn            is active low. 	0x1
PB13  DAC-CSn           is active low. 	0x1
PB12  ADC-CSn           is active low. 	0x1
PB11  SDA2              I2C START NOT USED
PB10  SCL2		
PB9   NC
PB8   NC
PB7   SDA1
PB6   SCL1              I2C END NOT USED
PB5   SPI1-MOSI         is AF, SPI1_MOSI 0x2
PB4   SPI1-MISO         is AF, SPI1_MISO 0x2
PB3   JTDO/SPI1-SCLK    is AF, SPI1_SCLK 0x2
PB2   BOOT0             Do not program	 0x0
PB1   ADC-PDN           is active low. 	 0x1
PB0   ADC-RSTn          is active high.	 0x1
)

(
\ --------------------------------PORTC-----------------------------------------
\ GPIO PORT C Reset value: 0x0000 0000
\ MODER is a 2 bit init for each of the 16 ports in a bank.
\ Enable PC5 as input, and PC0-2-15 as Outputs for the ADC GAIN SWITCHES.
\ USART3 inited on PORT C, in the first section, after system clocks setup.
\ PORTC - Do std GPIO and level set init. Then do alternate function config.
\ Intialize PORTC pins this way.
PC15
PC14
PC13
PC12
PC11    UART3_TX        is AF.
PC10    UART3_RX        is AF.
PC9     SWITCH4         is active high.
PC8     SWITCH3         is active high.
PC7     SWITCH2         is active high.
PC6     SWITCH1         is active high.
PC5     ADC_DATA_READY  is actve high.
PC4
PC3
PC2     GAIN_SWITCH2    is active low.
PC1     GAIN_SWITCH1    is active low.
PC0     GAIN_SWITCH0    is active low.
)

\ ------------------------------------------------------------------------------
\ BIT and BITS SET AND SEE WORDS FOR MEMORY AND REGISTER
\ update GLOSSARY WITH BETTER EXAMPLES/EXPLNATIONS

\ SPI1 BIT BANG WORDS
\ GPIOB- MODER 000000010100b 14h

: SET-BB 
  .SPI-REGISTERS
    GPIOB-ODR 14h SETBITS
  .SPI-REGISTERS
;

EHOFF

\ STACK SANITY CHECK
.S

: .SPI1-DUMP
\ SPI DIRECTION
.SPI1-DIRECTION?

\ DAC SWITCHES
.SW

.SPI1

.CS
\ FIX
\ FFh 7Fh A0h DAC-LB

\ .CS
\ FIX
\ FFh 7Fh A1h SPI1-ONLY-LB

\ SANITY CHECK WORDS
\ .CS
\ FFh 7Fh A0h ADC-LB
;

.SPI1-DUMP

\ WDR RDR ARE ATOMIC WORDS FOR THE LOOPBACK ISSUE.
EHON
\ Bit bang requires 
\ INIT FOR BIT BANG TEST, MODER is 2 bits wide per pin.
\ PB3 OUT       CLK
\ PB4 IN        MISO
\ PB5 OUT       MOSI

: .PB3 ." CLK ON PB3 IN BB IS " 2 GPIOB-ODR SEEBIT@	;

.PB3

PON

\ 3Dh WDR
(
GPIO WORDSET TO TEST:
SPI1-DAC-BB
CS-ADC
CS-BT
CS-DAC
SW1
SW2
SW3
SW4
GS2
GS1
GS0
CLRBITS
SETBITS
ANDBITS
CLRBIT
SETBIT
SEEBIT
)