\ DUP DOESNT ERROR WHEN STACK IS EMPTY. IT PUSHES A ZERO~!

POFF
EHON
\ PSTAT_

\ The spi1 register addresses.
040013000h CONSTANT	SPI1-CR1
040013004h CONSTANT	SPI1-CR2
040013008h CONSTANT	SPI1-SR
04001300Ch CONSTANT	SPI1-DR
040013010h CONSTANT	SPI1-CRCPR
040013014h CONSTANT	SPI1-RXCRCR
040013018h CONSTANT	SPI1-TXCRCR

: .SPI1 ( -- )
\ THIS IS RECURSIVELY PRINTING THE OUTPUT PATTERN WITH ? VALUES
	\ MY IMMEDIATE AND HEX ALT ISNT WORKING ON ? [ HEX ]
	CR
	." SPI1-CR1 ADDR IS: " SPI1-CR1 .H ." AND THE VALUE IS: " SPI1-CR1	@ .B	CR
	." SPI1-CR2 ADDR IS: " SPI1-CR2 .H ." AND THE VALUE IS: " SPI1-CR2	@ .B	CR
	." SPI1-SR ADDR IS: " SPI1-SR .H ." AND THE VALUE IS: " SPI1-SR	@ .B	CR
	." SPI1-DR ADDR IS: " SPI1-DR .H ." AND THE VALUE IS: " SPI1-DR	@ .B	CR
;

.SPI1

\ The gpio registers involved.
040020000h	CONSTANT	GPIOA-MODER
040020004h	CONSTANT	GPIOA-OTYPER
040020008h	CONSTANT	GPIOA-OSPEEDR
04002000Ch	CONSTANT	GPIOx-PUPDR
\ GPIOA_IDR                           40020010h
\ GPIOA_ODR                           40020014h
\ GPIOA_BSRR                          40020018h
\ GPIOA_LCKR                          4002001Ch
\ GPIOA_AFRL                          40020020h
\ GPIOA_AFRH                          40020024h

: WD ( n=8bits -- ) \ write to spi1 odr 7 layer fifo
	SPI1-DR C!
;


: DS BEGIN 0FFh DAC-WRITE ?KEY UNTIL ;

\ I NEED MACROS FOR A BUNCH OF THIS:
\ $ creation
\ WC creation
\ talking Create Does~!

\ SPI1 LOOPBACK TEST
: SR  CR ." SR = "
SPI1-SR @ DUP .H SPACE .B
;

: TS
CR
SPI1-CR1 @ 0C37Dh = IF ." IN UNIDIRECTIONAL MODE " THEN
SPI1-CR1 @ 037Dh = IF ." IN BIDIRECTIONAL  MODE " THEN
7 0 DO
45 I + DUP SPI1-DR C!
CR ." BYTE WROTE = " .H
SR
CR
." DR = " SPI1-DR ?
LOOP
;


// 1RST TRY DOCS HARD TO FIND~!
/*
typedef enum gpio_af {
    GPIO_AF_SPI_1_2              = 5,
    GPIO_AF_USART_1_2_3          = 7,
} gpio_af;
*/

/* Intialize PORTB_MODER pins this way.
Value at end is this init								...........
PB15  BT-RST	        is active high.	0x1
PB14  BT-CSn	        is active low. 	0x1 SANITYY CHECK CS-BT USES THIS!!!
PB13  DAC-CSn        	is active low. 	0x1
PB12	ADC-CSn					is active low. 	0x1
PB11	SDA2						I2C START (NOT USED)
PB10	SCL2
PB9		NC
PB8		NC
PB7		SDA1
PB6		SCL1						I2C END (NOT USED)
PB5		SPI1-MOSI				is AF, SPI1_MOSI 0x2
PB4		SPI1-MISO				is AF, SPI1_MISO 0x2
PB3		JTDO/SPI1-SCLK	is AF, SPI1_SCLK 0x2
PB2		BOOT0		        Do not program	 0x0
PB1		ADC-PDN	        is active low. 	 0x1
PB0     ADC-RSTn				is active high.	 0x1

//--------------------------------PORTC-----------------------------------------
// GPIO PORT C Reset value: 0x0000 0000


// MODER is a 2 bit init for each of the 16 ports in a bank.
// Enable PB0-1, and PB12-15 as Outputs for SPI BT, ADC and DAC BT RST
// PROGRAM SPI1 AF ON PB3, PB4 AND PB5
// USART3 inited on PORT C, in the first section, after system clocks setup.
// PORTC - Do std GPIO and level set init. Then do alternate function config.
/* Intialize PORTC pins this way.
Value at end is this init								...........
PC15
PC14
PC13
PC12
PC11    UART3_TX        is AF.
PC10    UART3_RX        is AF.
PC9     SWITCH4         is active high.
PC8     SWITCH3         is active high.
PC7     SWITCH2         is active high.
PC6     SWITCH1         is active high.
PC5     ADC_DATA_READY  is actve high.
PC4
PC3
PC2     GAIN_SWITCH2    is active low.
PC1     GAIN_SWITCH1    is active low.
PC0     GAIN_SWITCH0    is active low.

FOR PSTAT init add pc0-pc9 init here

QUIT
--
hmm, NEW~! afrh values for gpioc in cube~ INVESTIGATE~!!!

--
yay:
BUT lsb ORDER IS disordered is WHAT SCOPE SEEs~!
Yet register LSBFIRST bit is zero~!
\ CHECK RXE AND OVERRUN~!
Saw a 3C7h init of spi ....

\ BIT and BITS WORDS MEMORY OR REGISTER (update GLOSSARY)
EHON
POFF
\ The spi1 register addresses.
040013000h	CONSTANT	SPI1-CR1
040013004h	CONSTANT	SPI1-CR2
040013008h	CONSTANT	SPI1-SR
04001300Ch	CONSTANT	SPI1-DR

\ The gpio registers involved.
040020414h	CONSTANT	GPIOB-ODR
040020441h 	CONSTANT	GPIOA-IDR

\ The gpio registers involved.
040020814h	CONSTANT	GPIOC-ODR
040020810h	CONSTANT	GPIOC-IDR

\ 1 0 LSL .B 1b
\ 1 1 LSL .B 10b
\ 1 2 LSL .B 100b
\ 2 2 LSL .B 1000b
\ 3 2 LSL .B 1100b
\ 1 9 LSL .SB TOS> 1000000000b


\ THESE HAVE TO OR THE RESULTS BEFORE THE STORE
\ NOT WORKING YET
: SETBIT ( 1-based-bit# adrr -- )
		>R
   	1h SWAP LSL
		R	@	OR
\ OR WITH OTHER BITS
		R @ AND
\
		R> !
;

: CLRBIT ( 1-based-bit# addr -- )
		>R
   	1h SWAP LSL
		R @	NOT AND	\ XOR
\ OR WITH OTHER BITS
		R @ OR
\
		R> !
;

\ PSTAT SWITCH WORDS, ON THE DAC
: SW1 ( ON | OFF -- )	\ BIT 9
	IF GPIOC-ODR 1000000000b SETBITS ELSE GPIOC-ODR 1000000000b CLRBITS THEN CR ;

: SW2 ( ON | OFF -- )	\ BIT 8
	IF 8 GPIOC-ODR SETBIT ELSE 8 GPIOC-ODR CLRBIT THEN ;

: SW3 ( ON | OFF -- )	\ BIT 7
	IF 7 GPIOC-ODR SETBIT ELSE 7 GPIOC-ODR CLRBIT THEN ;

: SW4 ( ON | OFF -- )	\ BIT 6
	IF 6 GPIOC-ODR SETBIT ELSE 6 GPIOC-ODR CLRBIT THEN ;

\ SPI1 WORDS FOR THE DAC
: RX-OK? BEGIN SPI1-SR @ 2 AND UNTIL ;
\ : RX-OK?  ;

: DW ( n2 n1 -- )
	14d GPIOB-ODR CLRBIT \ DAC PB13 CS (LEDRED) low=ON
		RX-OK? 3Fh SPI1-DR !
		RX-OK? ( n1 )  SPI1-DR !
		RX-OK? ( n2 ) SPI1-DR !
	GPIOB-ODR 1 14d LSL SETBITS \ DAC PB13 CS (LEDRED) high=OFF
;
GPIOB-ODR 1 14d LSL CLRBITS
: TS
\	12d GPIOB-ODR CLRBIT \ BT PB14 (LEDGREEN) CS low=ON
	GPIOB-ODR 3 13d LSL CLRBITS \ DAC (LEDRED) and BT (LEDGREEN) CS low=ON PB13 & PB14
\	DO A 3 BYTE Write FOR THE DAC

\ CHECK FOR OVERRUN
\		SPI1-SR @ 0F0h AND IF ." OVERRUN ERROR, ABORTING " ABORT THEN
\ now do the 3 write ramp.

	FFh 0 DO	\ use I for the last 2 bytes and 1rst bYte will always be 3Fh
		I I DW
		1 MS
	LOOP	\ write spi dr

	GPIOB-ODR 3 13d LSL SETBITS \ DAC and BT CS HIGH PB13 & PB14
;

: RUN BEGIN TS ?KEY UNTIL ;

: SEEBIT@ ( 1-based-bit# addr -- )
	SWAP \ MAKES STACK ARGS SAME AS SETBIT/CLRBIT
	1 SWAP LSL >R @ R AND R> AND IF ." ON" ELSE ." OFF" THEN ;

\ THESE ARE NOT NEEDED AS: (VERIFIED)
\ .BT-CS	PB14	IS LEDGREEN
\ .DAC-CS	PB13	IS LEDRED
\ .ADC-CS	PB12	IS LEDBLUE
: .SW1 ." SW1 (PC6) IS " 9 GPIOC-ODR SEEBIT@	;
: .SW2 ." SW2 (PC7) IS " 8 GPIOC-ODR SEEBIT@	;
: .SW3 ." SW3 (PC8) IS " 7 GPIOC-ODR SEEBIT@	;
: .SW4 ." SW4 (PC9) IS " 6 GPIOC-ODR SEEBIT@	;

EHOFF
.SW1
.SW2
.SW3
.SW4

OFF SW1
.SW1

OFF SW2
.SW2
ON SW2
.SW2

\ RUN

PON


